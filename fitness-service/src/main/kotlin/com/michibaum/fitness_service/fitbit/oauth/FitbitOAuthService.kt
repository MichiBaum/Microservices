package com.michibaum.fitness_service.fitbit.oauth

import com.michibaum.authentication_library.security.netty.JwtToken
import org.springframework.stereotype.Service
import java.security.MessageDigest
import java.security.SecureRandom
import java.util.*

@Service
class FitbitOAuthService(val fitbitOAuthRepository: FitbitOAuthRepository) {

    fun save(fitbitOAuthData: FitbitOAuthData) =
        fitbitOAuthRepository.save(fitbitOAuthData)

    fun findByState(state: String) =
        fitbitOAuthRepository.findByState(state)

    /**
     * Generates and stores Fitbit OAuth data required for the PKCE (Proof Key for Code Exchange) flow.
     *
     * This method creates a cryptographically secure code verifier, a corresponding code challenge derived from it,
     * and a unique state value. These values are then encapsulated in a `FitbitOAuthData` object, which is persisted
     * to the repository.
     *
     * @return The newly created and saved `FitbitOAuthData` object containing the OAuth parameters.
     */
    fun generateData(principal: JwtToken): FitbitOAuthData {
        // PKCE Code Verifier | A cryptographically secure random value. Recommended for all apps and required when omitting the Client Secret.
        val codeVerifier = generateCodeVerifier()
        // PKCE Code Challenge | A base64-encoded SHA-256 transformation of the Code Verifier
        val codeChallenge = generateCodeChallenge(codeVerifier)
        // State | A unique value generated by the app which will be passed back to and validated by the app.
        val state = generateState()

        // Save codeVerifier, codeChallenge, state, UserId, createdTimestamp
        val fitbitOAuthData = FitbitOAuthData(
            codeVerifier = codeVerifier,
            codeChallenge = codeChallenge,
            state = state,
            userId = principal.getUserId()
        )
        return fitbitOAuthRepository.save(fitbitOAuthData)
    }

    /**
     * Generates a cryptographically secure random code verifier used in the OAuth PKCE (Proof Key for Code Exchange) flow.
     *
     * The generated code verifier is a URL-safe, base64-encoded string without padding.
     *
     * @return A unique code verifier value as a URL-safe, base64-encoded string.
     */
    private fun generateCodeVerifier(): String {
        val secureRandom = SecureRandom()
        val codeVerifier = ByteArray(32)
        secureRandom.nextBytes(codeVerifier)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(codeVerifier)
    }

    /**
     * Generates a code challenge using the provided code verifier. The code challenge is created
     * by computing the SHA-256 hash of the code verifier and encoding it using base64 URL-encoded
     * format without padding. This is used in the OAuth PKCE (Proof Key for Code Exchange) flow.
     *
     * @param codeVerifier The original code verifier string.
     * @return A base64 URL-encoded representation of the SHA-256 hash of the code verifier.
     */
    private fun generateCodeChallenge(codeVerifier: String): String {
        val bytes = codeVerifier.toByteArray(Charsets.US_ASCII)
        val messageDigest = MessageDigest.getInstance("SHA-256")
        val digestBytes = messageDigest.digest(bytes)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(digestBytes)
    }

    /**
     * Generates a cryptographically secure random state value used in the OAuth flow.
     *
     * The generated state is a URL-safe, base64-encoded string without padding.
     *
     * @return A unique state value as a URL-safe, base64-encoded string.
     */
    private fun generateState(): String {
        val secureRandom = SecureRandom()
        val state = ByteArray(16)
        secureRandom.nextBytes(state)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(state)
    }

}