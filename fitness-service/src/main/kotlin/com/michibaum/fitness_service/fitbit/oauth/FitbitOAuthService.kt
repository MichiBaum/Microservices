package com.michibaum.fitness_service.fitbit.oauth

import com.michibaum.authentication_library.security.jwt.JwtAuthentication
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.security.MessageDigest
import java.security.SecureRandom
import java.time.Instant
import java.util.*

@Service
class FitbitOAuthService(
    private val fitbitOAuthRepository: FitbitOAuthRepository,
    private val fitbitOAuthCredentialsRepository: FitbitOAuthCredentialsRepository
) {

    /**
     * Retrieves active Fitbit OAuth credentials for a given user.
     *
     * @param userId The unique identifier of the user whose active credentials are retrieved.
     * @return The active Fitbit OAuth credentials for the specified user.
     */
    fun activeCredentialsByUser(userId: String) =
        fitbitOAuthCredentialsRepository.findByUserIdAndDeactivatedFalse(userId)

    /**
     * Retrieves Fitbit OAuth data associated with a specific state value.
     *
     * @param state The unique state value associated with the Fitbit OAuth data.
     * @return The `FitbitOAuthData` object containing the code verifier and challenge.
     */
    fun findByState(state: String): FitbitOAuthData? =
        fitbitOAuthRepository.findByState(state)

    /**
     * Generates and stores Fitbit OAuth data required for the PKCE (Proof Key for Code Exchange) flow.
     *
     * This method creates a cryptographically secure code verifier, a corresponding code challenge derived from it,
     * and a unique state value. These values are then encapsulated in a `FitbitOAuthData` object, which is persisted
     * to the repository.
     *
     * @return The newly created and saved `FitbitOAuthData` object containing the OAuth parameters.
     */
    fun generateData(principal: JwtAuthentication): FitbitOAuthData {
        // PKCE Code Verifier | A cryptographically secure random value. Recommended for all apps and required when omitting the Client Secret.
        val codeVerifier = generateCodeVerifier()
        // PKCE Code Challenge | A base64-encoded SHA-256 transformation of the Code Verifier
        val codeChallenge = generateCodeChallenge(codeVerifier)
        // State | A unique value generated by the app which will be passed back to and validated by the app.
        val state = generateState()

        // Save codeVerifier, codeChallenge, state, UserId, createdTimestamp
        val fitbitOAuthData = FitbitOAuthData(
            codeVerifier = codeVerifier,
            codeChallenge = codeChallenge,
            state = state,
            userId = principal.getUserId()
        )
        return fitbitOAuthRepository.save(fitbitOAuthData)
    }

    /**
     * Generates a cryptographically secure random code verifier used in the OAuth PKCE (Proof Key for Code Exchange) flow.
     *
     * The generated code verifier is a URL-safe, base64-encoded string without padding.
     *
     * @return A unique code verifier value as a URL-safe, base64-encoded string.
     */
    private fun generateCodeVerifier(): String {
        val secureRandom = SecureRandom()
        val codeVerifier = ByteArray(32)
        secureRandom.nextBytes(codeVerifier)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(codeVerifier)
    }

    /**
     * Generates a code challenge using the provided code verifier. The code challenge is created
     * by computing the SHA-256 hash of the code verifier and encoding it using base64 URL-encoded
     * format without padding. This is used in the OAuth PKCE (Proof Key for Code Exchange) flow.
     *
     * @param codeVerifier The original code verifier string.
     * @return A base64 URL-encoded representation of the SHA-256 hash of the code verifier.
     */
    private fun generateCodeChallenge(codeVerifier: String): String {
        val bytes = codeVerifier.toByteArray(Charsets.US_ASCII)
        val messageDigest = MessageDigest.getInstance("SHA-256")
        val digestBytes = messageDigest.digest(bytes)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(digestBytes)
    }

    /**
     * Generates a cryptographically secure random state value used in the OAuth flow.
     *
     * The generated state is a URL-safe, base64-encoded string without padding.
     *
     * @return A unique state value as a URL-safe, base64-encoded string.
     */
    private fun generateState(): String {
        val secureRandom = SecureRandom()
        val state = ByteArray(16)
        secureRandom.nextBytes(state)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(state)
    }

    /**
     * Saves the Fitbit OAuth credentials to the repository.
     *
     * This method converts the provided `FitbitOAuthCredentialsDto` and `FitbitOAuthData`
     * into a `FitbitOAuthCredentials` entity and saves it to the `fitbitOAuthCredentialsRepository`.
     *
     * @param credentialsDto The DTO containing the OAuth credentials.
     * @param fitbitOAuthData The associated Fitbit OAuth data.
     */
    fun save(credentialsDto: FitbitOAuthCredentialsDto, fitbitOAuthData: FitbitOAuthData): FitbitOAuthCredentials {
        val fitbitOAuthCredentials = FitbitOAuthCredentials(
            accessToken = credentialsDto.accessToken,
            expiresIn = credentialsDto.expiresIn.toInt(),
            refreshToken = credentialsDto.refreshToken,
            scope = credentialsDto.scope,
            fitbitUserId = credentialsDto.userId,
            validUntil = Instant.now().plusSeconds(credentialsDto.expiresIn.toLong()),
            createdDate = Instant.now(),
            userId = fitbitOAuthData.userId,
        )

        return fitbitOAuthCredentialsRepository.save(fitbitOAuthCredentials)
    }

    /**
     * Persists new Fitbit OAuth credentials and deactivates the old ones.
     *
     * This method saves the new Fitbit OAuth credentials passed in the `new` parameter
     * and sets the `deactivated` flag of the old credentials to `true`, effectively
     * deactivating the old credentials. Both the new and old credentials are saved in the repository.
     *
     * @param new The new Fitbit OAuth credentials to be saved.
     * @param old The old Fitbit OAuth credentials to be deactivated.
     * @return The newly saved Fitbit OAuth credentials.
     */
    @Transactional
    fun saveNewAndDeactivateOld(new: FitbitOAuthCredentialsDto, old: FitbitOAuthCredentials): FitbitOAuthCredentials {
        val fitbitOAuthCredentials = FitbitOAuthCredentials(
            accessToken = new.accessToken,
            expiresIn = new.expiresIn.toInt(),
            refreshToken = new.refreshToken,
            scope = new.scope,
            fitbitUserId = new.userId,
            validUntil = Instant.now().plusSeconds(new.expiresIn.toLong()),
            createdDate = Instant.now(),
            userId = old.userId,
        )
        val newSaved = fitbitOAuthCredentialsRepository.save(fitbitOAuthCredentials)
        old.deactivated = true
        fitbitOAuthCredentialsRepository.save(old)
        return newSaved
    }

}